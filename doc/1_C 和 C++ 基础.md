## 1 c/c++ 简介

### 1.1 c 语言

### 1.2 c 语言编程原理

c 语言理论上可以实现 oop，但是代价比较大，毕竟不是原生支持。c 语言原生支持**结构化编程**，是一种过程性语言。

### 1.3 面向对象编程

与强调算法的过程性编程不同的是，oop 强调的是数据。oop 不像过程性编程那样，试图使问题满足语言的过程性方法，而是试图让语言来满足问题的要求。其理念是设计与问题的本质特性相对应的数据格式。

在 c++ 中，类是一种规范，它描述了这种新型数据格式，对象是根据这种规范构造的特定数据结构。通常，类规定了可使用那些数据来表示对象以及可以对这些数据执行哪些操作。oop 程序设计方法首先设计类，他们准确地表示了程序要处理的东西。类定义描述了对每个类可执行的操作。从低级组织（如类）到高级组织（如程序）的处理过程叫做自下而上（bottome-up）的编程。

oop 编程并不仅仅是将数据和方法合并为类定义。例如，oop 还有助于创建可重用的代码，这将减少大量的工作。信息隐藏（封装）可以保护数据，使其免遭不适当的访问。多态让你能够为运算符和函数创建多个定义（静态多态和动态多态），通过编程上下文来确定使用哪个定义。继承让你能够使用旧类派生出新类。

其实设计有用，可靠的类是一项艰巨的任务，对程序员的要求很高。所以 C++ 的优点是通过 OOP 使得程序员可以方便地重用和修改现有的，经过仔细测试过的类代码。

### 1.4 c++ 和泛型编程

它与 OOP 的目标相同，即使重用代码和抽象通用概念的技术更简单。不过 OOP 强调的是编程的数据方面，而泛型编程强调的是独立于特定数据类型。OOP 是一个管理大型项目的工具，而泛型编程提供了执行常见任务（如对数据排序或合并链表）的工具。术语泛型（generic）指的是创建独立于类型的代码。C++ 的数据表示有多种类型——整数、小数、字符、字符串、用户定义的、由多种类型组成的复合结构。例如，要对不同类型的数据进行排序，通常必须为每种类型创建一个排序函数。泛型编程需要对语言进行扩展，以便可以只编写一个泛型（即不是特定类型的）函数，并将其用于各种实际类型。**C++ 模板**提供了完成这种任务的机制。



## 2 变量和基本类型

## 3 字符串向量和数组

## 4 表达式

## 5 语句

## 6 函数

## 7 类

#### 类

类，定义了数据的存储和使用方式。类是用户定义的一种数据类型。要定义类，要描述它能够表示什么信息和对数据进行什么操作。类之于对象就像定义之于变量。函数调用和运算符重载，都可以用来向类的对象发送消息。面向对象编程的本质是设计并扩展自己的数据类型。

类定义了如何表示和控制数据。成员函数归类所有，描述了描述了操纵类数据的方法。





## 8 预处理器

c 语言是一个编译型语言，那么在源代码中除了逻辑相关的代码部分，还有编译相关的代码部分。编译相关的代码部分主要是预处理相关的部分。

编译一个 c 程序有很多步骤。详细见编译原理部分。

c 预处理器在源码编译之前对其进行一些文本性质的操作。它的主要任务包括删除注释，插入被 `#include` 指令包含的文件的内容，定义和替换由 `#define` 指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译。

## 1 预定义符号

下面总结了有预处理器定义的符号。它们的值或者是字符串常量，或者是十进制数字常量。`__FILE__` 和 `__LINE__` 在确认调试输出的来源方面很有用处。`__DATE__` 和 `__TIME__` 常常用于在被编译的程序中加入版本信息。`__STDC__` 用于那些在 ANSI 环境中和非 ANSI 中都必须进行编译的程序中结合条件编译。

| 符号       | 样例值        | 含义                                   |
| ---------- | ------------- | -------------------------------------- |
| `__FILE__` | "name.c"      | 进行编译的源文件名                     |
| `__LINE__` | 25            | 文件当前行的行号                       |
| `__DATE__` | "Jan 31 1997" | 文件被编译的日期                       |
| `__TIME__` | "18:04:30"    | 文件被编译的时间                       |
| `__STDC__` | 1             | 如果编译器遵循 ANSI 就为1， 否则未定义 |


## 2 #define

描述格式为：

```c
# define name stuff
```

有了上述指令，每当由符号 name 出现在这条指令后面时，预处理器就会把它替换成 stuff 

替换文本并不限于数值字面值常量。使用 #define 指令，你可以把任何文本替换到程序中。

如果定义中的 stuff 非常长，可以分成几行，除了最后一行之外，每行的末尾都要加一个反斜杠。下面是示例：

```c
#include "stdio.h"

#define DEBUG_PRINT printf("File %s is line %d:" \
                        " x=%d, y=%d, z=%d", \
                        __FILE__, __LINE__, \
                        x, y, z)

int main()
{
    int x = 3, y = 4, z = 5;
    x *= 2;
    y += x;
    z = x * y;
    DEBUG_PRINT;
    return 0;
}
```

不要滥用上述技巧，吐过相同的代码需要出现在几个地方，更好的办法是实现为一个函数。

### 2.1 宏

#define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义宏（defined macro）。下面是宏的声明方式：

```c
#define name(parameter-list) stuff
```

其中，parameter-list（参数列表）是一个由逗号分隔的符号列表，他们可能出现在 stuff 中。参数列表的左括号必须与  name 相邻。如果两者之间有任何空白存在，参数列表就会被解释成 stuff 的一部分。

当宏被调用时，名字后面是一个由逗号分隔的值的列表，每个值都与宏定义的一个参数相对应，整个列表用一对括号包围。当参数出现在程序中时，与每个参数对应的实际值都将被替换到哦 stuff 中。

那么理论上，通过定义一套宏，用一种看上去很想其他语言的方式编写 c 程序是完全可能的，但是不应该这样做。

### 2.2 #define 替换

在程序中扩展#define定义符号和宏时，需要涉及几个步骤。

1．在调用宏时，首先对参数进行检查，看看是否包含了任何由#define定义的符号。如果是，它们首先被替换。

2．替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被它们的值所替代。

3．最后，再次对结果文本进行扫描，看看它是否包含了任何由#define定义的符号。如果是，就重复上述处理过程。

这样，宏参数和#define定义可以包含其他#define定义的符号。但是，宏不可以出现递归。

详见 c 与指针 14.2.2 中阐述

### 2.3 宏与函数 

宏非常频繁地用于执行简单的计算，比如在两个表达式中寻找其中较大（或较小）的一个：

```c
#define MAX(a, b) ((a) > (b) ? (a) : (b)) // 想想看这里为啥加这么多括号
```

不用函数的原因有两个。首先是用于调用和从函数返回的代码很可能比实际执行这个小型计算工具的代码更大，所以使用宏比使用函数在程序的规模和速度方面更胜一筹。

最关键的是，函数的参数必须声明为一种特定的类型，所以它只能在类型合适的表达式上使用。反之，上面这个宏可以用于整形，长整型，单浮点型，双浮点数以及其他任何可以用 > 这个操作符比较值大小的类型。换句话说，宏是与类型无关的。

宏的不利之处在于每次使用时，一份宏定义代码的拷贝都将插入程序中。除非宏非常短，否则使用宏可能会大幅度增加程序的长度。

还有一些任务根本无法用函数实现。比如下面这个宏

```c
#define MALLOC(n, type) \
		((type *)malloc( (n) * sizeof(type)))
```

宏的第二个参数是一种类型，它无法作为函数参数进行传递。

## 2.4 带副作用的宏参数







面向对象的特性：

构造函数

析构函数

运算符重载

动态绑定

常用的设计模式

c++对内存的使用管理

编程能力（字符串处理），并发控制，语言的基本概念

计算机系统基础知识

内存管理，文件操作，程序性能，多线程，程序安全

在c++中有哪四个与类型转换相关的关键字？这些关键字各有什么特点，应该在什么场合下使用？

sizeof函数

剑指第一二题：考察c++语法，不懂！！！！

c++动态创建结构体

c++ utility





#### 名称空间

对于同名函数，编译器不知道使用哪个版本的函数时，可以将其放入不同的名称空间，通过名称空间：：函数的方式调用函数。



原型和定义是两个不同的概念，原型只描述了函数接口，而定义包含了函数的代码。c和c++将这两个特性（原型和定义）分开了，库文件包括了函数的编译代码，而头文件则包含了原型。



变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: `a_local_variable`, `a_struct_data_member`, `a_class_data_member_`





#### 算术运算符

五种基本的算术运算符：加减乘除，取模。



#### 复合类型

从c语言继承下来的复合类型：数组，结构，指针。

数组：用来存储多个同类型的数据，创建数组使用声明语句，需要声明三点：

1.存储在数组中每个元素的值的类型

2.数组的名称

3.数组中的元素数。

通用格式：`typename name[arraysize]`，arraysize指定元素数目，它必须是整形常量或const值，也可以是常量表达式，即**其中的值在编译时是已知**的。具体地说，arraysize不能是变量，变量的值是在程序运行时设置的。（虽然这个规则非常的操蛋）但素，可以使用new运算符来避开这种限制。只有在定义数组时才能初始化，后续不能再初始化，不能用一个数组初始化另一个数组。

结构：用来存储多个不同类型的数据。

可以同时完成结构定义和创建结构变量的工作。只需将变量名称放在结束括号的后面即可。

结构中的位字段：

联合体，共用体（union)：可以存储不同的数据类型，但同时只能存储其中的一种类型。共用体通常用于节省内存。

枚举：一种创建符号常量的方式。默认情况下，将整数值赋给枚举量，第一个枚举量的值为0，第二个枚举量的值为1，依次类推。可以通过显式地指定整数值的方式覆盖默认值。在声明枚举量的时候，可以使用赋值运算符来显式地设置枚举量的值。

指针：用来告知计算机数据所处位置，使用指针来管理运行阶段的内存分配。指针无非是为可以通过名称访问的内存地址提供了一个别名，但其真正的用武之地是但运行阶段提供未命名的内存以保存值。在这种情况下，只能使用指针来访问内存。c语言中可以使用库函数malloc来分配内存，c++中仍然可以这样做，但是最好使用new运算符。为一个数据对象（可以是结构，也可以是基本数据类型）获得并指定分配内存的通用格式是：`typename *pointer_name = new typename` 只能用delete释放new分配的内存，不能用于释放声明变量获得的内存。



类：oop的堡垒。c++的灵魂

## typedef

c语言机制，允许为各种数据定义新名字。typedef声明的写法和普通的声明基本相同，只是把typedef这个关键字出现在声明的前面。例如，下面这个声明：

```c
char　　　*ptr_to_char;
```

把变量ptr_to_char声明为一个指向字符的指针。但是，在你添加关键字typedef后，声明变为：
`typedef　 char　 *ptr_to_char;`
这个声明把标识符ptr_to_char作为指向字符的指针类型的新名字。你可以像使用任何预定义名字一样在下面的声明中使用这个新名字。例如：
`ptr_to_char　　　a;`
声明a是一个指向字符的指针。
使用typedef声明类型可以减少使声明变得又臭又长的危险，尤其是那些复杂的声明。而且，如果你以后觉得应该修改程序所使用的一些数据的类型时，修改一个typedef声明比修改程序中与这种类型有关的所有变量（和函数）的所有声明要容易得多。

### 提示：

你应该使用typedef而不是#define来创建新的类型名，因为后者无法正确地处理指针类型。例如：
`#define　d_ptr_to_char　 char *`
`d_ptr_to_char　 a, b;`
正确地声明了 a，但是 b 却被声明为一个字符。因为 #define 只是简单的将d_ptr_to_char 转换成了char* , 然后语句变成了：

char *  a, b;(所以b为一个字符)

在定义更为复杂的类型名字时，如函数指针或指向数组的指针，使用typedef更为合适。

## 构造函数（参考c++大学教程p59）

声明**一个或多个**构造函数用于类对象创建时它的初始化，构造函数是一种特殊的成员函数，定义时必须和类同名，这样编译器才能够将它和类的其他成员函数区分开来。构造函数不能返回值，因此不可以指定返回类型。通常情况下，构造函数声明为public。类一般只有以一个构造函数，利用函数重载技术，可以创建有多个构造函数的类。

### sizeof关键字

统计数据类型所占内存大小

语法：sizeof(数据 or 变量);

### 转义字符

\a       响铃(BEL)     007 

\b       退格(BS)      008 

\f       换页(FF)      012 

\n       换行(LF)      010  

\r       回车(CR)      013 

\t       水平制表(HT)  009 

\v       垂直制表(VT)  011 

\\       反斜杠         092 

\?       问号字符       063 

\'       单引号字符     039 

\"       双引号字符     034 

\0       空字符        000 

switch语句

作用：执行多条件分支语句

语法：

```c++
switch(表达式)

{

​	case 结果1： 执行语句； break；

​	case 结果2： 执行语句； break；

​	...

​	default: 执行语句；break；

}
```

### const修饰指针

三种情况

1.  const 修饰指针 --- 常量指针，const int *p = &a；**指针的指向可以修改，指针指向的值不可以修改** 

2.  const 修饰常量 --- 指针常量,	int * const p = &a；**指针的指向不可以改，指针指向的值可以改**

3.  const 既修饰指针，又修饰常量，const int * const p = &a；**指针的指向和指针指向的值都不可以改**

#### 结构体创建

struct 结构体名 变量名

struct 结构体名 变量名 = {成员1值，成员2值...}







## 函数提高

### 函数默认参数

c++中，函数的形参列表中形参是可以有默认值的

注意：

1.如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值

2.如果函数声明有默认参数，函数的实现不能有默认参数（在声明和实现分离时必须保证这一点 ）声明和实现只能有一个有默认参数

### 函数占位参数

c++函数的形参列表可以有占位参数，用来做占位，调用函数时必须填补该位置。

占位参数也有用，也可以有默认参数

### 函数重载，还有运算符重载（后面学）

作用名可以相同，提高复用性

函数重载满足条件

同一个作用域下
函数名不同
函数参数**类型不同** 或者 **个数不同** 或者 **顺序不同**

注意：函数的返回值不可以作为函数重载的条件

​			引用作为函数重载条件，常量引用和变量引用是不同的数据类型

​			函数重载碰到默认参数，出现二义性，避免这种情况，重载函数不要写默认参数





类的基本思想是数据抽象和封装。

## 4. 类和对象

面向对象三大特性：封装，继承，多态

万事万物皆为对象，对象上有属性和行为

具有相同性质的对象，抽象为类。

### 4.1 封装

#### 4.1.1 封装的意义

将属性和行为作为一个整体，变现生活中的事物

将属性和行为加以权限控制

语法：`class 类名{ 访问权限： 属性 / 行为}；`



#### 4.1.2 访问权限

1.  public 公共权限     成员在类内可以访问，类外也可以访问

2.  protected 保护权限		 成员类内可以访问，类外不可以访问（在继承的时候，体现区别，继承有父子关系，父亲的保护权限儿子可以访问）

3.  private 私有权限		类内可以访问，类外不可以访问（在继承的时候，体现区别，继承有父子关系，父亲的私有权限儿子不可以访问）



#### 4.1.3struct和class的区别

c++中struct和class唯一的区别就在于默认的访问权限不同

区别：

​	struct默认权限为公共

​	class默认权限为私有

#### 将成员属性设置为私有

优点：将所有成员属性设置为私有，可以控制读写权限，对于写权限，可以检测数据的有效性

