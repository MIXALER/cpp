本阶段主要针对 C++ 泛型编程和 STL 技术做详细讲解

## 1 模板

### 1.1 模板的概念

模板的特点

-   模板不可以直接使用，它只是一个框架
-   模板的通用并不是万能的

### 1.2 函数模板

-   c++ 另一种编程思想称为 **泛型编程**，主要利用的技术就是模板
-   c++ 提供两种模板机制： **函数模板** 和 **类模板**

#### 1.2.1 函数模板语法

函数模板作用：

简历一个通用的函数，其函数返回值类型和形参类型可以不具体制定，用一个**虚拟的类型**来代表

语法：

```c++
template<typename T>

函数声明或定义
```

解释：

template -- 声明创建模板

typename -- 表面其后面的符号是一种数据类型，可以用 class 代替

T -- 通用的数据类型，名称可以替换，通常为大写字母

```c++
template<typename T>
void mySwap(T &a, T &b)
{
    T tmp;
    tmp = a;
    a = b;
    b = tmp;
}

int main()
{
    int a = 10;
    int b = 20;
    // 自动类型推导
//    mySwap(a, b);
    // 显示指定类型
    mySwap<int>(a, b);
    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
    return 0;
}
```

类型参数化

#### 1.2.2 函数模板的注意事项

-   自动类型推导，必须推导出一致的数据类型 T，才可以使用
-   模板必须要确定出 T 的数据类型，才可以使用

#### 1.2.3 普通函数与函数模板的区别

-   普通函数调用时可以发生自动类型转换（隐式类型转换）
-   函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
-   如果利用显示指定类型的方式调用函数模板，可以发生隐式类型转换

#### 1.2.4 普通函数与函数模板的调用规则

1.  如果函数模板和普通函数都可以实现，优先调用普通函数
2.  可以通过**空模板参数**列表来强制调用函数模板
3.  函数模板也可以发生重载
4.  如果函数模板可以**产生更好的匹配**，优先调用函数模板（调用普通函数需要做隐式类型转换，而调用模板不需要时）
5.  如果提供了函数模板，最好不要提供普通函数，否则容易出现二义性

#### 1.2.4 模板的局限性

模板的通用不是万能的

```c++
template<class T>

void f(T a, T b)

{

​	a = b;

}
```

上述代码的赋值操作对于 a 和 b 是数组的情况就会报错

因此 c++ 为了解决这种问题，提供模板的重载，可以为这些**特定的类型**提供**具体化的模板**

### 1.3 类模板

建立一个通用类，类中的成员 数据类型可以不具体绑定，用一个**虚拟的类型**来代表

#### 1.3.1 类模板语法

```c++
template<class T>
类定义

```

