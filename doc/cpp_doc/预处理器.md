## 预处理器

c 语言是一个编译型语言，那么在源代码中除了逻辑相关的代码部分，还有编译相关的代码部分。编译相关的代码部分主要是预处理相关的部分。

编译一个 c 程序有很多步骤。详细见编译原理部分。

c 预处理器在源码编译之前对其进行一些文本性质的操作。它的主要任务包括删除注释，插入被 `#include` 指令包含的文件的内容，定义和替换由 `#define` 指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译。

## 1 预定义符号

下面总结了有预处理器定义的符号。它们的值或者是字符串常量，或者是十进制数字常量。`__FILE__` 和 `__LINE__` 在确认调试输出的来源方面很有用处。`__DATE__` 和 `__TIME__` 常常用于在被编译的程序中加入版本信息。`__STDC__` 用于那些在 ANSI 环境中和非 ANSI 中都必须进行编译的程序中结合条件编译。

| 符号       | 样例值        | 含义                                   |
| ---------- | ------------- | -------------------------------------- |
| `__FILE__` | "name.c"      | 进行编译的源文件名                     |
| `__LINE__` | 25            | 文件当前行的行号                       |
| `__DATE__` | "Jan 31 1997" | 文件被编译的日期                       |
| `__TIME__` | "18:04:30"    | 文件被编译的时间                       |
| `__STDC__` | 1             | 如果编译器遵循 ANSI 就为1， 否则未定义 |


## 2 #define

描述格式为：

```c
# define name stuff
```

有了上述指令，每当由符号 name 出现在这条指令后面时，预处理器就会把它替换成 stuff 

替换文本并不限于数值字面值常量。使用 #define 指令，你可以把任何文本替换到程序中。

如果定义中的 stuff 非常长，可以分成几行，除了最后一行之外，每行的末尾都要加一个反斜杠。下面是示例：

```c
#include "stdio.h"

#define DEBUG_PRINT printf("File %s is line %d:" \
                        " x=%d, y=%d, z=%d", \
                        __FILE__, __LINE__, \
                        x, y, z)

int main()
{
    int x = 3, y = 4, z = 5;
    x *= 2;
    y += x;
    z = x * y;
    DEBUG_PRINT;
    return 0;
}
```

不要滥用上述技巧，吐过相同的代码需要出现在几个地方，更好的办法是实现为一个函数。

### 2.1 宏

#define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义宏（defined macro）。下面是宏的声明方式：

```c
#define name(parameter-list) stuff
```

其中，parameter-list（参数列表）是一个由逗号分隔的符号列表，他们可能出现在 stuff 中。参数列表的左括号必须与  name 相邻。如果两者之间有任何空白存在，参数列表就会被解释成 stuff 的一部分。

当宏被调用时，名字后面是一个由逗号分隔的值的列表，每个值都与宏定义的一个参数相对应，整个列表用一对括号包围。当参数出现在程序中时，与每个参数对应的实际值都将被替换到哦 stuff 中。

那么理论上，通过定义一套宏，用一种看上去很想其他语言的方式编写 c 程序是完全可能的，但是不应该这样做。

### 2.2 #define 替换

在程序中扩展#define定义符号和宏时，需要涉及几个步骤。

1．在调用宏时，首先对参数进行检查，看看是否包含了任何由#define定义的符号。如果是，它们首先被替换。

2．替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被它们的值所替代。

3．最后，再次对结果文本进行扫描，看看它是否包含了任何由#define定义的符号。如果是，就重复上述处理过程。

这样，宏参数和#define定义可以包含其他#define定义的符号。但是，宏不可以出现递归。

详见 c 与指针 14.2.2 中阐述

### 2.3 宏与函数 

宏非常频繁地用于执行简单的计算，比如在两个表达式中寻找其中较大（或较小）的一个：

```c
#define MAX(a, b) ((a) > (b) ? (a) : (b)) // 想想看这里为啥加这么多括号
```

不用函数的原因有两个。首先是用于调用和从函数返回的代码很可能比实际执行这个小型计算工具的代码更大，所以使用宏比使用函数在程序的规模和速度方面更胜一筹。

最关键的是，函数的参数必须声明为一种特定的类型，所以它只能在类型合适的表达式上使用。反之，上面这个宏可以用于整形，长整型，单浮点型，双浮点数以及其他任何可以用 > 这个操作符比较值大小的类型。换句话说，宏是与类型无关的。

宏的不利之处在于每次使用时，一份宏定义代码的拷贝都将插入程序中。除非宏非常短，否则使用宏可能会大幅度增加程序的长度。

还有一些任务根本无法用函数实现。比如下面这个宏

```c
#define MALLOC(n, type) \
		((type *)malloc( (n) * sizeof(type)))
```

宏的第二个参数是一种类型，它无法作为函数参数进行传递。

## 2.4 带副作用的宏参数

