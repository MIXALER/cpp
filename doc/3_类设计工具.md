### 4.2对象的初始化和清理

电子产品基本上都有出厂设置，在某一天不用时也会删除自己的信息保证数据安全

c++的每个对象都会有初始设置以及对象销毁前的清理数据的设置

#### 构造函数和析构函数

对象的初始化和清理是非常重要的安全问题

​	一个对象或者变量没有初始状态，对其使用后果是未知

​	同样使用万一个变量或对象，没有及时清理，也会造成一定的安全问题

c++ 利用了构造函数和析构函数来解决上述问题，这两个函数会被编译器自动调用，完成对象初始化和清理工作。对象初始化和清理工作是编译器强制要求我们做的事情，因此如果我们不提供构造和析构，编译器会提供，编译器提供的构造函数和析构函数是空实现。

构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数编译器自动调用，无须手动调用。

析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。

构造函数语法：类名()){}

1.  构造函数，没有返回值也不写void
2.  函数名称和类名相同
3.  构造函数可以有参数，因此可以发生重载
4.  程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次

析构函数语法： ~类名(){}

1.  析构函数，没有返回值也不写void
2.  函数名称与类名相同，在名称前加上符号 ~
3.  析构函数不可以有参数，因此不可以发生重载
4.  程序在对象销毁前自动调用析构，无须手动调用，而且只会调用一次

#### 构造函数的分类及调用

两种分类方式：

​	按参数分为：有参构造和无参构造

​	按类型分为：普通构造和拷贝构造

三种调用方式：

​	括号法，调用默认构造函数的时候，不能加 () ，因为编译器会认为是一个函数的声明，不会认为在创建对象

​	显示法

​	隐式转换法



#### 拷贝构造函数调用时机

三种情况

​	使用一个已经创建完毕的对象来初始化一个新对象

​	值传递的方式给函数参数传值

​	以值方式返回局部对象



#### 构造函数调用规则

默认情况下，c++编译器至少给一个类添加三个函数

1.  默认构造函数（无参，函数体为空）
2.  默认析构函数（无参，函数体为空）
3.  默认拷贝构造函数，对属性进行值拷贝

调用规则如下：

如果用户定义有参构造函数，c++ 不再提供默认无参构造函数，但是会提供默认拷贝构造

如果用户定义拷贝构造函数，c++ 不再提供其他构造函数

可以理解为默认构造 < 有参构造 < 拷贝构造函数 编译器只会自动添加高一级的构造函数

#### 深拷贝和浅拷贝

浅拷贝：简单的赋值拷贝操作，如果赋值的值中包括指针，然后指针会指向一个在堆区分配的空间，对象释放时调用析构函数会释放堆区的空间。那么拷贝的对象在释放时也会用析构函数释放堆区的空间，从而导致堆区的内存重复释放。

示例代码如下：

```c++
class Person
{
public:
    //构造函数，没有返回值，不用写void
    //可以有参数，可以发生重载
    Person()
    {
        cout<< "Person 默认（无参）构造函数的调用" << endl;
    }

    Person(int val, int height)
    {
        age = val;
        height_ = new int(height);
        cout << "Person 有参构造函数的调用" << endl;
    }

    //拷贝构造函数，拷贝一个已有对象的属性, const确保只读，并且只能用引用的方式传参
    Person(const Person &person)
    {
        //将传入的对象的所有属性，拷贝过来。
        age = person.age;
        height_ = person.height_;
        cout<< "Person 拷贝构造函数的调用" << endl;
    }

    //析构函数，没有返回值，不用写void
    //函数名和类名相同，在名称前加 ~
    //析构函数没有参数，不可以重载
    ~Person()
    {
        //析构函数，将堆区开辟的数据做释放操作
        if(height_ != nullptr)
        {
            delete height_;
            height_ = nullptr;
        }
        cout << "Person 析构函数的调用" << endl;
    }

public:
    int age;
    int *height_;
};

// 深拷贝和浅拷贝
void test01()
{
    Person person(18, 160);
    Person person2(person);

    cout << "p1的年龄为： " << person.age <<  "身高为： " << *person.height_  << endl;
    cout << "p2的年龄为： " << person2.age << "身高为： " << *person2.height_  << endl;



}


int main()
{
    test01();
    return 0;
}
```



深拷贝：拷贝构造函数中在堆区重新申请空间，进行拷贝操作，析构函数释放堆区内存就不会重复释放内存，示例代码如下：

```c++
class Person
{
public:
    //构造函数，没有返回值，不用写void
    //可以有参数，可以发生重载
    Person()
    {
        cout<< "Person 默认（无参）构造函数的调用" << endl;
    }

    Person(int val, int height)
    {
        age = val;
        height_ = new int(height);
        cout << "Person 有参构造函数的调用" << endl;
    }

    //拷贝构造函数，拷贝一个已有对象的属性, const确保只读，并且只能用引用的方式传参
    Person(const Person &person)
    {
        //将传入的对象的所有属性，拷贝过来。
        age = person.age;
        height_ = new int(*person.height_); //深拷贝，重新在堆区分配内存空间
        cout<< "Person 拷贝构造函数的调用" << endl;
    }

    //析构函数，没有返回值，不用写void
    //函数名和类名相同，在名称前加 ~
    //析构函数没有参数，不可以重载
    ~Person()
    {
        //析构函数，将堆区开辟的数据做释放操作
        if(height_ != nullptr)
        {
            delete height_;
            height_ = nullptr;
        }
        cout << "Person 析构函数的调用" << endl;
    }

public:
    int age;
    int *height_;
};

// 深拷贝和浅拷贝
void test01()
{
    Person person(18, 160);
    Person person2(person);

    cout << "p1的年龄为： " << person.age <<  "身高为： " << *person.height_  << endl;
    cout << "p2的年龄为： " << person2.age << "身高为： " << *person2.height_  << endl;



}


int main()
{
    test01();
    return 0;
}
```

如果属性有在堆区开辟的，一定要提供拷贝构造函数，防止浅拷贝带来的问题。



#### 初始化列表

c++提供了初始化列表，用来初始化属性

语法：构造函数（）：属性1（值1），属性2（值2）... {}



#### 类对象作为类成员

例如：

```c++
class A
{
    
};

class B
{
    A a;
};
```

创建B的对象时，A与B的构造和析构的顺序是谁先谁后。

当其他类的对象作为本类的成员，先构造其他类的对象，再构造自身

析构的顺序和构造的相反

#### 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：

-   静态成员变量
    -   所有对象共享同一份数据
    -   在编译器阶段分配内存
    -   类内声明，类外初始化
-   静态成员函数
    -   所有对象共享同一个函数
    -   静态成员函数只能访问静态成员变量



### 4.3 c++ 对象模型和 this 指针

成员变量和成员函数分开存储

在c++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上

#### this指针概念

c++中成员变量和成员函数是分开存储的

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分哪个对象调用自己的呢？



c++通过特殊的对象指针，this指针，解决上述问题。**this 指针指向被调用的成员函数所属的对象**



this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可



this指针用途

-   当形参和成员变量同名时，可用this指针区分
-   在类的非静态成员函数中返回对象本身，可使用 return *this

#### 空指针访问成员函数

c++中空指针也可以调用成员函数，但是也要注意有没有用到 this 指针

如果用到 this 指针，需要加以判断保证代码的健壮性

#### const修饰成员函数

常函数：

-   成员函数后加const后我们成这个函数为**常函数**
-   常函数内不可以修改成员属性
-   成员属性声明时加关键字 mutable 后，在常函数中依然可以修改

常对象：

-   声明对象前加 const 称该对象为常对象
-   常对象只能调用常函数

### 4.4 友元

在程序里，有些私有属性，也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术

友元的目的是让一个函数或者类，访问另一个类的私有成员

友元的关键字 friend

友元的三种实现

-   全局函数做友元
-   类做友元
-   成员函数做友元

### 4.5 运算符重载

概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型

#### 4.5.1 加号运算符重载

作用：实现两个自定义数据类型相加额运算

对于内置的数据类型的表达式的运算符是不可能改变的

不要滥用运算符重载

#### 4.5.2 左移运算符重载

作用：可以输出自定义数据类型

通常不会利用成员函数重载 << 运算符，因为无法实现 cout 在左侧。只能利用全局函数去重载 << 运算符

重载一个 << 运算符配合一个友元可以实现输出自定义数据类型

#### 4.5.3 递增运算符重载

通过重载递增运算符，实现自己的整形数据

前置递增返回引用，后置递增返回的是值

#### 4.5.4 赋值运算符重载

c++编译器至少给一个类添加4个函数

1.  默认构造函数（无参，空实现）
2.  默认析构函数（无参，函数体为空）
3.  默认拷贝函数，对属性进行值拷贝
4.  赋值运算符 operator= 对属性进行值拷贝

如果类中有属性指向堆区，做赋值操作时也会出现浅拷贝的问题（析构会重复释放内存）

#### 4.5.5 关系运算符重载

重载关系运算符，可以让两个自定义数据类型进行比较

### 4.6 继承

**继承是面向对象编程三大特性之一**

下级别的成员除了拥有上一级的共性，还有自己的特性。

#### 4.6.1 继承的基本语法

#### 4.6.2 继承的方式

继承的语法： `class 子类 : 继承方式 父类`

继承方式一共由三种：

-   公共继承：公共成员和保护成员到子类依然是公共成员和保护成员，私有成员到子类不可访问
-   保护继承：公共成员和保护成员到子类都变成保护成员，私有成员到子类不可访问
-   私有继承：公共成员和保护成员到子类都变成私有成员，私有成员到子类不可访问

#### 4.6.3 继承中的对象模型

从父类继承过来的成员，哪些属于子类对象中？

父类中所有非静态成员属性都会被子类继承下去

父类中私有成员属性，被编译器隐藏了，访问不到，但是确实被继承下去了。

#### 4.6.4 继承中的构造和析构顺序

子类继承父类后，当创建子类对象，也会调用父类的构造函数

问题：父类和子类的构造和析构顺序是谁先谁后？

继承中先调用父类的构造，再调用子类的构造，子类先调用析构，父类后调用析构

#### 4.6.5 继承同名成员处理方式

当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？

-   访问子类同名成员 直接访问即可
-   访问父类同名成员 需要加作用域

如果子类中出现和父类同名的成员函数，子类的同名成员函数回隐藏掉父类中的所有（重载）同名成员函数，如果想访问，需要加作用域

#### 4.6.6 继承同名静态成员处理方式

继承中同名的静态成员在子类对象上如何进行访问

静态成员和非静态成员出现同名，处理方式一致

-   访问子类同名成员 直接访问即可
-   访问父类同名成员 需要加作用域

总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）

#### 4.6.7 多继承语法

c++允许**一个类继承多个类**

语法：`class 子类 : 继承方式 父类1 , 继承方式 父类2...`

多继承可能回引发父类中有同名成员出现，需要加作用域区分

**c++实际开发中不建议用多继承**

#### 4.6.8 菱形继承

概念：

1.  两个派生类同时继承一个基类
2.  又有某个类同时继承两个派生类
3.  这种继承被称为菱形继承，或者叫做钻石继承

当出现菱形继承，两个父类拥有相同数据，需要加以作用域区分

利用虚继承可以解决菱形继承的问题，在继承之前加上关键字：virtual

原理：虚基类，最大的类。

虚基类指针：从父类继承下来的vbptr，指向vbtable，记录偏移量，加上偏移量，会找到唯一一个数据成员。最终保存的成员只有一个。

### 4.7 多态

#### 4.7.1 基本概念

多态是面向对象的三大特性之一

多态分为两类：

-   静态多态：函数重载 和 运算符重载属于静态多态，复用函数名
-   动态多态：派生类和虚函数实现运行时多态

静态多态和动态多态区别：

-   静态多态的函数地址早绑定 - 编译阶段确定函数地址
-   动态多态的函数地址晚绑定 - 运行阶段确定函数地址

动态多态满足条件：

1.  有继承关系
2.  子类**重写**父类同名虚函数，子类的 `virtual` 关键字可写可不写

动态多态使用条件：

**父类的指针或者引用，执行子类对象**

​	

虚函数实现原理：

vfptr ：虚函数表指针，指向一个虚函数表，vftable，表内部记录记录一个虚函数地址。







本阶段主要针对 C++ 泛型编程和 STL 技术做详细讲解

## 1 模板

### 1.1 模板的概念

模板的特点

-   模板不可以直接使用，它只是一个框架
-   模板的通用并不是万能的

### 1.2 函数模板

-   c++ 另一种编程思想称为 **泛型编程**，主要利用的技术就是模板
-   c++ 提供两种模板机制： **函数模板** 和 **类模板**

#### 1.2.1 函数模板语法

函数模板作用：

简历一个通用的函数，其函数返回值类型和形参类型可以不具体制定，用一个**虚拟的类型**来代表

语法：

```c++
template<typename T>

函数声明或定义
```

解释：

template -- 声明创建模板

typename -- 表面其后面的符号是一种数据类型，可以用 class 代替

T -- 通用的数据类型，名称可以替换，通常为大写字母

```c++
template<typename T>
void mySwap(T &a, T &b)
{
    T tmp;
    tmp = a;
    a = b;
    b = tmp;
}

int main()
{
    int a = 10;
    int b = 20;
    // 自动类型推导
//    mySwap(a, b);
    // 显示指定类型
    mySwap<int>(a, b);
    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
    return 0;
}
```

类型参数化

#### 1.2.2 函数模板的注意事项

-   自动类型推导，必须推导出一致的数据类型 T，才可以使用
-   模板必须要确定出 T 的数据类型，才可以使用

#### 1.2.3 普通函数与函数模板的区别

-   普通函数调用时可以发生自动类型转换（隐式类型转换）
-   函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
-   如果利用显示指定类型的方式调用函数模板，可以发生隐式类型转换

#### 1.2.4 普通函数与函数模板的调用规则

1.  如果函数模板和普通函数都可以实现，优先调用普通函数
2.  可以通过**空模板参数**列表来强制调用函数模板
3.  函数模板也可以发生重载
4.  如果函数模板可以**产生更好的匹配**，优先调用函数模板（调用普通函数需要做隐式类型转换，而调用模板不需要时）
5.  如果提供了函数模板，最好不要提供普通函数，否则容易出现二义性

#### 1.2.4 模板的局限性

模板的通用不是万能的

```c++
template<class T>

void f(T a, T b)

{

​	a = b;

}
```

上述代码的赋值操作对于 a 和 b 是数组的情况就会报错

因此 c++ 为了解决这种问题，提供模板的重载，可以为这些**特定的类型**提供**具体化的模板**

### 1.3 类模板

建立一个通用类，类中的成员 数据类型可以不具体绑定，用一个**虚拟的类型**来代表

#### 1.3.1 类模板语法

```c++
template<class T>
类定义

```



## 1 继承的基本概念和语法

### 1.1 **继承和派生**是同一过程从不同的角度看

-   保持已有类的忒行而构造新类的过程称为继承
-   在已有类的基础上新增自己的特性而产生新类的过程称为派生

被继承的已有类称为基类（或父类）

派生出的新类称为派生类（或子类）

直接参与派生出某类的基类称为直接基类

基类的基类甚至更高层的基类称为间接基类

### 1.2 继承的目的

实现设计与代码的重用

### 1.3 派生的目的

当新的问题出现，原有程序无法解决（或不能完全解决）是，需要对原有程序加以改造。

单继承时派生类的定义

语法

```c++
class 派生类名 ： 继承方式 基类名
{
​	成员声明；
}
```

多继承时派生类的定义

语法

```
class 派生类名 ： 继承方式 基类名1， 继承方式2 基类名2，...
{
	成员声明；
}
```

派生类的构成

-   吸收基类成员

    -   默认情况下构造函数和析构函数是不被继承的
    -   c++11 规定可以用 using 关键字继承基类构造函数

-   改造基类成员

    派生类声明了一个和某基类成员同名的新成员，派生类的新成员就隐藏或覆盖了外层同名成员

-   添加新的成员


继承方式简介及公有继承

不同继承方式的影响主要体现在：

-   派生类成员对基类成员的访问权限
-   通过派生类对象对基类成员的访问权限

## 2 三种继承方式

-   公有继承
    -   访问控制
        -   基类的 public 和 protected 成员：访问属性在派生类中保持不变
        -   基类的 private 成员：不可直接访问
    -   访问权限
        -   派生类中的成员函数：可以直接访问基类中的 public 和 protected 成员，但不能直接访问基类的 private 成员；
        -   通过派生类的对象：只能访问 public 成员
-   私有继承
    -   访问控制
        -   基类的 public 和 protected 成员：都以 private 身份出现在派生类中
        -   基类的 private 成员：不可直接访问
    -   访问权限
        -   派生类中的成员函数：可以直接访问基类中的 public 和 protected 成员，但不能直接访问基类的 private 成员；
        -   通过派生类的对象：不能直接访问从基类继承的任何成员
-   保护继承
    -   访问控制
        -   基类的 public 和 protected 成员：都以 protected 身份出现在派生类中
        -   基类的 private 成员：不可直接访问
    -   访问权限
        -   派生类中的成员函数：可以直接访问基类中的 public 和 protected 成员，但不能直接访问基类的 private 成员；
        -   通过派生类的对象：不能直接访问从基类继承的任何成员

-   protected 成员的特点与作用
    -   对于建立起所在类对象的模块来说，它与 private 成员的性质相同
    -   对于其派生类来说，它与 public 成员的性质相同
    -   既实现了数据隐藏，又方便继承，实现代码重用

## 2 基类与派生类类型转换









## 1 单独编译

作用：可不止让代码结构更加清晰这么简单

四个步骤

1.  创建后缀名为 .h 的文件
2.  创建后缀名为 .cpp 的文件
3.  在头文件中写函数的声明
4.  在源文件中写函数的定义

## 2 存储持续性，作用域和链接性

## 3 名称空间

名称可以是变量，函数，结构，枚举，类以及类和结构的成员。随着项目增大，名称相互冲突的可能性也增加。使用多个厂商的类库是，可能导致名称冲突。这种冲突称为名称空间问题



















