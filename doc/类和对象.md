## 4. 类和对象

面向对象三大特性：封装，继承，多态

万事万物皆为对象，对象上有属性和行为

具有相同性质的对象，抽象为类。

### 4.1 封装

#### 4.1.1 封装的意义

将属性和行为作为一个整体，变现生活中的事物

将属性和行为加以权限控制

语法：`class 类名{ 访问权限： 属性 / 行为}；`



#### 4.1.2 访问权限

1.  public 公共权限     成员在类内可以访问，类外也可以访问

2.  protected 保护权限		 成员类内可以访问，类外不可以访问（在继承的时候，体现区别，继承有父子关系，父亲的保护权限儿子可以访问）

3.  private 私有权限		类内可以访问，类外不可以访问（在继承的时候，体现区别，继承有父子关系，父亲的私有权限儿子不可以访问）



#### 4.1.3struct和class的区别

c++中struct和class唯一的区别就在于默认的访问权限不同

区别：

​	struct默认权限为公共

​	class默认权限为私有

#### 将成员属性设置为私有

优点：将所有成员属性设置为私有，可以控制读写权限，对于写权限，可以检测数据的有效性



### 4.2对象的初始化和清理

电子产品基本上都有出厂设置，在某一天不用时也会删除自己的信息保证数据安全

c++的每个对象都会有初始设置以及对象销毁前的清理数据的设置

#### 构造函数和析构函数

对象的初始化和清理是非常重要的安全问题

​	一个对象或者变量没有初始状态，对其使用后果是未知

​	同样使用万一个变量或对象，没有及时清理，也会造成一定的安全问题

c++ 利用了构造函数和析构函数来解决上述问题，这两个函数会被编译器自动调用，完成对象初始化和清理工作。对象初始化和清理工作是编译器强制要求我们做的事情，因此如果我们不提供构造和析构，编译器会提供，编译器提供的构造函数和析构函数是空实现。

构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数编译器自动调用，无须手动调用。

析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。

构造函数语法：类名()){}

1.  构造函数，没有返回值也不写void
2.  函数名称和类名相同
3.  构造函数可以有参数，因此可以发生重载
4.  程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次

析构函数语法： ~类名(){}

1.  析构函数，没有返回值也不写void
2.  函数名称与类名相同，在名称前加上符号 ~
3.  析构函数不可以有参数，因此不可以发生重载
4.  程序在对象销毁前自动调用析构，无须手动调用，而且只会调用一次

#### 构造函数的分类及调用

两种分类方式：

​	按参数分为：有参构造和无参构造

​	按类型分为：普通构造和拷贝构造

三种调用方式：

​	括号法，调用默认构造函数的时候，不能加 () ，因为编译器会认为是一个函数的声明，不会认为在创建对象

​	显示法

​	隐式转换法



#### 拷贝构造函数调用时机

三种情况

​	使用一个已经创建完毕的对象来初始化一个新对象

​	值传递的方式给函数参数传值

​	以值方式返回局部对象



#### 构造函数调用规则

默认情况下，c++编译器至少给一个类添加三个函数

1.  默认构造函数（无参，函数体为空）
2.  默认析构函数（无参，函数体为空）
3.  默认拷贝构造函数，对属性进行值拷贝

调用规则如下：

如果用户定义有参构造函数，c++ 不再提供默认无参构造函数，但是会提供默认拷贝构造

如果用户定义拷贝构造函数，c++ 不再提供其他构造函数

可以理解为默认构造 < 有参构造 < 拷贝构造函数 编译器只会自动添加高一级的构造函数

#### 深拷贝和浅拷贝

浅拷贝：简单的赋值拷贝操作，如果赋值的值中包括指针，然后指针会指向一个在堆区分配的空间，对象释放时调用析构函数会释放堆区的空间。那么拷贝的对象在释放时也会用析构函数释放堆区的空间，从而导致堆区的内存重复释放。

示例代码如下：

```c++
class Person
{
public:
    //构造函数，没有返回值，不用写void
    //可以有参数，可以发生重载
    Person()
    {
        cout<< "Person 默认（无参）构造函数的调用" << endl;
    }

    Person(int val, int height)
    {
        age = val;
        height_ = new int(height);
        cout << "Person 有参构造函数的调用" << endl;
    }

    //拷贝构造函数，拷贝一个已有对象的属性, const确保只读，并且只能用引用的方式传参
    Person(const Person &person)
    {
        //将传入的对象的所有属性，拷贝过来。
        age = person.age;
        height_ = person.height_;
        cout<< "Person 拷贝构造函数的调用" << endl;
    }

    //析构函数，没有返回值，不用写void
    //函数名和类名相同，在名称前加 ~
    //析构函数没有参数，不可以重载
    ~Person()
    {
        //析构函数，将堆区开辟的数据做释放操作
        if(height_ != nullptr)
        {
            delete height_;
            height_ = nullptr;
        }
        cout << "Person 析构函数的调用" << endl;
    }

public:
    int age;
    int *height_;
};

// 深拷贝和浅拷贝
void test01()
{
    Person person(18, 160);
    Person person2(person);

    cout << "p1的年龄为： " << person.age <<  "身高为： " << *person.height_  << endl;
    cout << "p2的年龄为： " << person2.age << "身高为： " << *person2.height_  << endl;



}


int main()
{
    test01();
    return 0;
}
```



深拷贝：拷贝构造函数中在堆区重新申请空间，进行拷贝操作，析构函数释放堆区内存就不会重复释放内存，示例代码如下：

```c++
class Person
{
public:
    //构造函数，没有返回值，不用写void
    //可以有参数，可以发生重载
    Person()
    {
        cout<< "Person 默认（无参）构造函数的调用" << endl;
    }

    Person(int val, int height)
    {
        age = val;
        height_ = new int(height);
        cout << "Person 有参构造函数的调用" << endl;
    }

    //拷贝构造函数，拷贝一个已有对象的属性, const确保只读，并且只能用引用的方式传参
    Person(const Person &person)
    {
        //将传入的对象的所有属性，拷贝过来。
        age = person.age;
        height_ = new int(*person.height_); //深拷贝，重新在堆区分配内存空间
        cout<< "Person 拷贝构造函数的调用" << endl;
    }

    //析构函数，没有返回值，不用写void
    //函数名和类名相同，在名称前加 ~
    //析构函数没有参数，不可以重载
    ~Person()
    {
        //析构函数，将堆区开辟的数据做释放操作
        if(height_ != nullptr)
        {
            delete height_;
            height_ = nullptr;
        }
        cout << "Person 析构函数的调用" << endl;
    }

public:
    int age;
    int *height_;
};

// 深拷贝和浅拷贝
void test01()
{
    Person person(18, 160);
    Person person2(person);

    cout << "p1的年龄为： " << person.age <<  "身高为： " << *person.height_  << endl;
    cout << "p2的年龄为： " << person2.age << "身高为： " << *person2.height_  << endl;



}


int main()
{
    test01();
    return 0;
}
```

如果属性有在堆区开辟的，一定要提供拷贝构造函数，防止浅拷贝带来的问题。



#### 初始化列表

c++提供了初始化列表，用来初始化属性

语法：构造函数（）：属性1（值1），属性2（值2）... {}



#### 类对象作为类成员

例如：

```c++
class A
{
    
};

class B
{
    A a;
};
```

创建B的对象时，A与B的构造和析构的顺序是谁先谁后。

当其他类的对象作为本类的成员，先构造其他类的对象，再构造自身

析构的顺序和构造的相反

#### 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：

-   静态成员变量
    -   所有对象共享同一份数据
    -   在编译器阶段分配内存
    -   类内声明，类外初始化
-   静态成员函数
    -   所有对象共享同一个函数
    -   静态成员函数只能访问静态成员变量



### 4.3 c++ 对象模型和 this 指针

成员变量和成员函数分开存储

在c++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上

#### this指针概念

c++中成员变量和成员函数是分开存储的

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分哪个对象调用自己的呢？



c++通过特殊的对象指针，this指针，解决上述问题。**this 指针指向被调用的成员函数所属的对象**



this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可



this指针用途

-   当形参和成员变量同名时，可用this指针区分
-   在类的非静态成员函数中返回对象本身，可使用 return *this

#### 空指针访问成员函数

c++中空指针也可以调用成员函数，但是也要注意有没有用到 this 指针

如果用到 this 指针，需要加以判断保证代码的健壮性

#### const修饰成员函数

常函数：

-   成员函数后加const后我们成这个函数为**常函数**
-   常函数内不可以修改成员属性
-   成员属性声明时加关键字 mutable 后，在常函数中依然可以修改

常对象：

-   声明对象前加 const 称该对象为常对象
-   常对象只能调用常函数

### 4.4 友元

在程序里，有些私有属性，也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术

友元的目的是让一个函数或者类，访问另一个类的私有成员

友元的关键字 friend

友元的三种实现

-   全局函数做友元
-   类做友元
-   成员函数做友元

### 4.5 运算符重载

概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型

#### 4.5.1 加号运算符重载

作用：实现两个自定义数据类型相加额运算

对于内置的数据类型的表达式的运算符是不可能改变的

不要滥用运算符重载

#### 4.5.2 左移运算符重载

作用：可以输出自定义数据类型

通常不会利用成员函数重载 << 运算符，因为无法实现 cout 在左侧。只能利用全局函数去重载 << 运算符

重载一个 << 运算符配合一个友元可以实现输出自定义数据类型

#### 4.5.3 递增运算符重载

通过重载递增运算符，实现自己的整形数据

前置递增返回引用，后置递增返回的是值

#### 4.5.4 赋值运算符重载

c++编译器至少给一个类添加4个函数

1.  默认构造函数（无参，空实现）
2.  默认析构函数（无参，函数体为空）
3.  默认拷贝函数，对属性进行值拷贝
4.  赋值运算符 operator= 对属性进行值拷贝

如果类中有属性指向堆区，做赋值操作时也会出现浅拷贝的问题（析构会重复释放内存）

#### 4.5.5 关系运算符重载

重载关系运算符，可以让两个自定义数据类型进行比较

### 4.6 继承

**继承是面向对象编程三大特性之一**

下级别的成员除了拥有上一级的共性，还有自己的特性。

#### 4.6.1 继承的基本语法

#### 4.6.2 继承的方式

继承的语法： `class 子类 : 继承方式 父类`

继承方式一共由三种：

-   公共继承：公共成员和保护成员到子类依然是公共成员和保护成员，私有成员到子类不可访问
-   保护继承：公共成员和保护成员到子类都变成保护成员，私有成员到子类不可访问
-   私有继承：公共成员和保护成员到子类都变成私有成员，私有成员到子类不可访问

#### 4.6.3 继承中的对象模型

从父类继承过来的成员，哪些属于子类对象中？

父类中所有非静态成员属性都会被子类继承下去

父类中私有成员属性，被编译器隐藏了，访问不到，但是确实被继承下去了。

#### 4.6.4 继承中的构造和析构顺序

子类继承父类后，当创建子类对象，也会调用父类的构造函数

问题：父类和子类的构造和析构顺序是谁先谁后？

继承中先调用父类的构造，再调用子类的构造，子类先调用析构，父类后调用析构

#### 4.6.5 继承同名成员处理方式

当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？

-   访问子类同名成员 直接访问即可
-   访问父类同名成员 需要加作用域

如果子类中出现和父类同名的成员函数，子类的同名成员函数回隐藏掉父类中的所有（重载）同名成员函数，如果想访问，需要加作用域

#### 4.6.6 继承同名静态成员处理方式

继承中同名的静态成员在子类对象上如何进行访问

静态成员和非静态成员出现同名，处理方式一致

-   访问子类同名成员 直接访问即可
-   访问父类同名成员 需要加作用域

总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）

#### 4.6.7 多继承语法

c++允许**一个类继承多个类**

语法：`class 子类 : 继承方式 父类1 , 继承方式 父类2...`

多继承可能回引发父类中有同名成员出现，需要加作用域区分

**c++实际开发中不建议用多继承**

#### 4.6.8 菱形继承

概念：

1.  两个派生类同时继承一个基类
2.  又有某个类同时继承两个派生类
3.  这种继承被称为菱形继承，或者叫做钻石继承

当出现菱形继承，两个父类拥有相同数据，需要加以作用域区分

利用虚继承可以解决菱形继承的问题，在继承之前加上关键字：virtual

原理：虚基类，最大的类。

虚基类指针：从父类继承下来的vbptr，指向vbtable，记录偏移量，加上偏移量，会找到唯一一个数据成员。最终保存的成员只有一个。

### 4.7 多态

#### 4.7.1 基本概念

多态是面向对象的三大特性之一

多态分为两类：

-   静态多态：函数重载 和 运算符重载属于静态多态，复用函数名
-   动态多态：派生类和虚函数实现运行时多态

静态多态和动态多态区别：

-   静态多态的函数地址早绑定 - 编译阶段确定函数地址
-   动态多态的函数地址晚绑定 - 运行阶段确定函数地址

动态多态满足条件：

1.  有继承关系
2.  子类**重写**父类同名虚函数，子类的 `virtual` 关键字可写可不写

动态多态使用条件：

**父类的指针或者引用，执行子类对象**

​	

虚函数实现原理：

vfptr ：虚函数表指针，指向一个虚函数表，vftable，表内部记录记录一个虚函数地址。































